MySQL8.0设置远程访问权限
1.登录MySQL
mysql -u root -p
输入您的密码

2.选择 mysql 数据库
use mysql;
因为 mysql 数据库中存储了用户信息的 user 表。

3.在 mysql 数据库的 user 表中查看当前 root 用户的相关信息
SELECT HOST, USER, AUTHENTICATION_STRING, PLUGIN FROM USER;
执行完上面的命令后会显示一个表格
查看表格中 root 用户的 host，默认应该显示的 localhost，只支持本地访问，不允许远程访问。

4.授权 root 用户的所有权限并设置远程访问
GRANT ALL ON *.* TO 'root'@'%';
GRANT ALL ON 表示所有权限，% 表示通配所有 host，可以访问远程。

5.刷新权限
所有操作后，应执行
FLUSH PRIVILEGES;

6.查看 root 用户的 host
再次执行步骤 2，你会发现 root 用户的 host 已经变成 %，说明我们的修改已经成功，可以远程访问了。

7.访问数据库
远程访问数据库的可视化工具比较多如：Navicat、SQLyog、MySQL workbench 等，我这里使用 Navicat

输入访问的 host 和密码，报 2059 错误，这是因为 MySql8.0 版本 和 5.0 的加密规则不一样，而现在的可视化工具只支持旧的加密方式。

此问题有两种方法，一种是更新 Navicat 驱动来解决此问题，另一种是将 MySQL 用户登录的加密规则修改为 mysql_native_password，第一种方法我试过了没有起作用，我这里采用第二种方法。

8.修改加密规则
ALTER USER 'root'@'localhost' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER;
password 为你当前密码。

9.更新 root 用户密码
ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'password';
password 为你新设置的密码。

10.刷新权限
FLUSH PRIVILEGES;

---------------------
C:\ProgramData\MySQL\MySQL Server 8.0


CREATE TABLE TEST(
    NAME VARCHAR(10) BINARY
);
SELECT * FROM TABLE TEST WHERE BINARY NAME='Clip';

# If set to 0, will throw an error on case-insensitive operative systems
# If set to 1, table names are stored in lowercase on disk and comparisons are not case sensitive.
# If set to 2, table names are stored as given but compared in lowercase.
# This option also applies to database names and table aliases.
# NOTE: Modify this value after Server initialization won't take effect.
# 0：区分大小写，1：不区分大小写
lower_case_table_names = 0

SET GLOBAL max_allowed_packet = 2*1024*1024*10

ALTER TABLE TEST CONVERT TO CHARACTER SET "utf8mb4" COLLATE "utf8mb4_bin";

------------------------------------------------------------------------------------------------------------------------
# CALL UPPERCASE('库名')
DROP PROCEDURE IF EXISTS uppercase;
CREATE PROCEDURE uppercase(IN dbname VARCHAR(200))
BEGIN

DECLARE done INT DEFAULT 0;
DECLARE oldname VARCHAR(200);
DECLARE cur CURSOR FOR SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = dbname;
DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

OPEN cur;

REPEAT

FETCH cur INTO oldname;

SET @newname = UPPER(oldname);
SET @isNotSame = @newname <> BINARY oldname;
IF NOT done && @isNotSame THEN
SET @SQL = CONCAT('RENAME TABLE `',oldname,'` TO `', LOWER(@newname), '_tmp` ');
PREPARE tmpstmt FROM @SQL;
EXECUTE tmpstmt;

SET @SQL = CONCAT('RENAME TABLE `',LOWER(@newname),'_tmp` TO `',@newname, '`');
PREPARE tmpstmt FROM @SQL;
EXECUTE tmpstmt;

DEALLOCATE PREPARE tmpstmt;

END IF;
UNTIL done END REPEAT;
CLOSE cur;
END
------------------------------------------------------------------------------------------------------------------------

RENAME TABLE test TO test_, test_ TO TEST;

ALTER TABLE test RENAME TO TEST;


------------------------------------------------------------------------------------------------------------------------
# 慢查询日志
SHOW VARIABLES LIKE 'slow_query%';
SHOW VARIABLES LIKE 'long_query_time';

SET GLOBAL slow_query_log='ON';
SET GLOBAL slow_query_log_file='/usr/local/mysql/data/slow.log';
SET GLOBAL long_query_time=3;
SET GLOBAL log-queries-not-using-indexes=ON
SET GLOBAL log-slow-admin-statements=ON
SET GLOBAL log_output='FILE,TABLE';

[mysqld]
# 指定是否开启慢查询日志 ON|OFF (1|0)缺省关闭
slow_query_log = ON
# 旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log
log-slow-queries = host_name-slow.log
# 指定慢日志文件存放位置，可以为空，系统会给一个缺省的文件host_name-slow.log
slow_query_log_file = /usr/local/mysql/data/host_name-slow.log
# 慢查询阀值，当查询时间超出设定值的SQL即被记录到慢查询日志，单位为妙，缺省值为10s
long_query_time = 3
# 查询检查返回少于该参数指定行的SQL不被记录到慢查询日志
min_examined_row_limit = ON
# 未使用索引的查询也被记录到慢查询日志中（可选项）
log-queries-not-using-indexes = ON
# 开启记录管理型慢SQL。缺省情况下数据库相关管理型SQL(比如OPTIMIZE TABLE、ANALYZE TABLE和ALTER TABLE)不会被记录到日志。
log-slow-admin-statements = ON
# 每分钟允许记录到slow log的且未使用索引的SQL语句次数。该值默认为0，表示没有限制，在生产环境下，若没有使用索引，此类SQL语句会频繁地被
# 记录到slow log，从而导致slow log文件的大小不断增加，故DBA可通过此参数进行配置。该参数MySQL 5.6.5版本开始新增
log_throttle_queries_not_using_indexes = ON
# 日志存储方式 FILE TABLE log-output='FILE,TABLE'
log-output='TABLE'


SELECT * FROM MYSQL.SLOW_LOG ORDER BY START_TIME DESC;

SELECT * FROM MYSQL.SLOW_LOG;
SET GLOBAL SLOW_QUERY_LOG = 'OFF';
ALTER TABLE MYSQL.SLOW_LOG RENAME MYSQL.SLOW_LOG_BACKUP;
SET GLOBAL SLOW_QUERY_LOG = 'ON';
DROP TABLE MYSQL.SLOW_LOG_BACKUP;
------------------------------------------------------------------------------------------------------------------------
binlog日志


log_bin=ON
log_bin_basename=/var/lib/mysql/mysql-bin
log_bin_index=/var/lib/mysql/mysql-bin.index

OR

log-bin=/var/lib/mysql/mysql-bin

# 5.7及以上版本
server-id=123454


SHOW VARIABLES LIKE 'log_bin%';
------------------------------------------------------------------------------------------------------------------------
show full processlist;
kill id;


#批量kill
1)查找Lockd语句
mysql -uroot -p123456 -h 192.1.20.101 -e "show processlist" | grep -i 'Locked' > locked_log.txt

2）组合kill
for line in `cat locked_log.txt | awk '{print $1}'`
do
   echo "kill $line;" >> kill_thread_id.sql
done

3)执行
mysql>source kill_thread_id.sql

------------------------------------------------------------------------------------------------------------------------
# MySQL根据配置文件会限制Server接受的数据包大小。有时候大的插入和更新会受 max_allowed_packet 参数限制，导致大数据写入或者更新失败。
SET GLOBAL max_allowed_packet = 2*1024*1024*10



------------------------------------------------------------------------------------------------------------------------


SHOW FULL PROCESSLIST
KILL 11108

## 当前运行的所有事务
SELECT * FROM information_schema.INNODB_TRX
## 当前出现的锁
SELECT * FROM  information_schema.INNODB_LOCKS;
## 锁等待的对应关系
SELECT * FROM  information_schema.INNODB_LOCK_WAITS

SHOW VARIABLES LIKE  '%innodb_lock_wait_timeout%'
SHOW GLOBAL VARIABLES LIKE  '%innodb_lock_wait_timeout%'

SET GLOBAL INNODB_LOCK_WAIT_TIMEOUT = 300;

------------------------------------------------------------------------------------------------------------------------
